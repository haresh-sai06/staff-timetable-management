
export interface Subject {
  id: string;
  name: string;
  code: string;
  type: "lab" | "theory";
  credits: number;
  department: string;
  year: string;
  semester: string;
  priority: "morning" | "afternoon" | "flexible";
}

export interface Staff {
  id: string;
  name: string;
  role: "Prof" | "AsstProf";
  department: string;
  maxHours: number;
  currentHours: number;
}

export interface Classroom {
  id: string;
  name: string;
  type: "lecture" | "lab";
  capacity: number;
  department: string;
}

export interface StudentGroup {
  id: string;
  name: string;
  department: string;
  year: string;
  strength: number;
}

export interface TimetableEntry {
  id: string;
  day: string;
  timeSlot: string;
  subject: string;
  subjectCode: string;
  staff: string;
  staffRole: string;
  classroom: string;
  studentGroup: string;
  type: string;
  hasConflict?: boolean;
  conflictType?: string;
  isAutoGenerated?: boolean;
}

export interface Conflict {
  type: string;
  description: string;
  severity: "low" | "medium" | "high";
}

export interface ScheduleResult {
  timetable: TimetableEntry[];
  conflicts: Conflict[];
}

class TimetableScheduler {
  private days = ["Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"];
  private timeSlots = [
    "08:00-09:00", "09:00-10:00", "10:00-11:00", "11:00-12:00",
    "12:00-13:00", "13:00-14:00", "14:00-15:00", "15:00-16:00", "16:00-17:00"
  ];

  generateTimetable(
    subjects: Subject[],
    staff: Staff[],
    classrooms: Classroom[],
    studentGroups: StudentGroup[],
    department: string,
    year: string,
    semester: string
  ): ScheduleResult {
    const timetable: TimetableEntry[] = [];
    const conflicts: Conflict[] = [];
    const assignedSlots: Set<string> = new Set();

    try {
      // Filter subjects for the specific department, year, and semester
      const relevantSubjects = subjects.filter(
        subject => 
          subject.department === department && 
          subject.year === year && 
          subject.semester === semester
      );

      // Filter staff for the department
      const departmentStaff = staff.filter(s => s.department === department);
      
      // Filter classrooms for the department
      const departmentClassrooms = classrooms.filter(c => c.department === department);
      
      // Filter student groups for the department and year
      const relevantGroups = studentGroups.filter(
        group => group.department === department && group.year === year
      );

      if (relevantSubjects.length === 0) {
        conflicts.push({
          type: "no_subjects",
          description: `No subjects found for ${department} ${year} year ${semester} semester`,
          severity: "high"
        });
        return { timetable, conflicts };
      }

      // Schedule each subject
      for (const subject of relevantSubjects) {
        let scheduled = false;
        
        // Find appropriate staff (simplified - assign first available)
        const availableStaff = departmentStaff.find(s => s.currentHours < s.maxHours);
        if (!availableStaff) {
          conflicts.push({
            type: "staff_unavailable",
            description: `No available staff for ${subject.name}`,
            severity: "high"
          });
          continue;
        }

        // Find appropriate classroom
        const requiredClassroomType = subject.type === "lab" ? "lab" : "lecture";
        const availableClassroom = departmentClassrooms.find(c => c.type === requiredClassroomType);
        if (!availableClassroom) {
          conflicts.push({
            type: "classroom_unavailable",
            description: `No ${requiredClassroomType} classroom available for ${subject.name}`,
            severity: "high"
          });
          continue;
        }

        // Find student group
        const studentGroup = relevantGroups[0]; // Simplified - use first group
        if (!studentGroup) {
          conflicts.push({
            type: "no_student_group",
            description: `No student group found for ${subject.name}`,
            severity: "high"
          });
          continue;
        }

        // Try to schedule in preferred time slots
        const preferredSlots = this.getPreferredTimeSlots(subject.priority);
        
        for (const day of this.days) {
          for (const timeSlot of preferredSlots) {
            const slotKey = `${day}-${timeSlot}-${availableClassroom.id}`;
            const staffSlotKey = `${day}-${timeSlot}-${availableStaff.id}`;
            const groupSlotKey = `${day}-${timeSlot}-${studentGroup.id}`;
            
            if (!assignedSlots.has(slotKey) && 
                !assignedSlots.has(staffSlotKey) && 
                !assignedSlots.has(groupSlotKey)) {
              
              // Create timetable entry
              const entry: TimetableEntry = {
                id: `${subject.id}-${day}-${timeSlot}`,
                day,
                timeSlot,
                subject: subject.name,
                subjectCode: subject.code,
                staff: availableStaff.name,
                staffRole: availableStaff.role,
                classroom: availableClassroom.name,
                studentGroup: studentGroup.name,
                type: subject.type,
                hasConflict: false,
                isAutoGenerated: true
              };

              timetable.push(entry);
              assignedSlots.add(slotKey);
              assignedSlots.add(staffSlotKey);
              assignedSlots.add(groupSlotKey);
              
              // Update staff hours
              availableStaff.currentHours += 1;
              scheduled = true;
              break;
            }
          }
          if (scheduled) break;
        }

        if (!scheduled) {
          conflicts.push({
            type: "scheduling_conflict",
            description: `Could not schedule ${subject.name} - no available time slots`,
            severity: "medium"
          });
        }
      }

      // Validate for conflicts
      this.validateSchedule(timetable, conflicts);

    } catch (error) {
      conflicts.push({
        type: "system_error",
        description: `Scheduling failed: ${error instanceof Error ? error.message : 'Unknown error'}`,
        severity: "high"
      });
    }

    return { timetable, conflicts };
  }

  private getPreferredTimeSlots(priority: "morning" | "afternoon" | "flexible"): string[] {
    const morningSlots = ["08:00-09:00", "09:00-10:00", "10:00-11:00", "11:00-12:00"];
    const afternoonSlots = ["13:00-14:00", "14:00-15:00", "15:00-16:00", "16:00-17:00"];
    
    switch (priority) {
      case "morning":
        return [...morningSlots, ...afternoonSlots];
      case "afternoon":
        return [...afternoonSlots, ...morningSlots];
      default:
        return [...morningSlots, ...afternoonSlots];
    }
  }

  private validateSchedule(timetable: TimetableEntry[], conflicts: Conflict[]): void {
    // Check for conflicts in the generated timetable
    const slotMap = new Map<string, TimetableEntry[]>();
    
    timetable.forEach(entry => {
      const key = `${entry.day}-${entry.timeSlot}`;
      if (!slotMap.has(key)) {
        slotMap.set(key, []);
      }
      slotMap.get(key)!.push(entry);
    });

    // Check for multiple entries in same slot for same resource
    slotMap.forEach((entries, slot) => {
      if (entries.length > 1) {
        const staffConflicts = this.findDuplicates(entries, 'staff');
        const classroomConflicts = this.findDuplicates(entries, 'classroom');
        const groupConflicts = this.findDuplicates(entries, 'studentGroup');

        staffConflicts.forEach(staff => {
          conflicts.push({
            type: "staff_conflict",
            description: `${staff} has multiple classes scheduled at ${slot}`,
            severity: "high"
          });
        });

        classroomConflicts.forEach(classroom => {
          conflicts.push({
            type: "classroom_conflict",
            description: `${classroom} has multiple classes scheduled at ${slot}`,
            severity: "high"
          });
        });

        groupConflicts.forEach(group => {
          conflicts.push({
            type: "student_group_conflict",
            description: `${group} has multiple classes scheduled at ${slot}`,
            severity: "high"
          });
        });
      }
    });
  }

  private findDuplicates(entries: TimetableEntry[], field: keyof TimetableEntry): string[] {
    const seen = new Set<string>();
    const duplicates = new Set<string>();
    
    entries.forEach(entry => {
      const value = entry[field] as string;
      if (seen.has(value)) {
        duplicates.add(value);
      } else {
        seen.add(value);
      }
    });
    
    return Array.from(duplicates);
  }
}

export const timetableScheduler = new TimetableScheduler();
