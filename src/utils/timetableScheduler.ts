
export interface Staff {
  id: string;
  name: string;
  role: "Prof" | "AsstProf";
  department: string;
  maxHours: number;
  currentHours: number;
}

export interface Subject {
  id: string;
  name: string;
  code: string;
  type: "theory" | "lab";
  credits: number;
  department: string;
  year: string;
  semester: string;
  priority: "morning" | "afternoon" | "any";
}

export interface Classroom {
  id: string;
  name: string;
  type: "lecture" | "lab" | "seminar";
  capacity: number;
  department: string;
}

export interface StudentGroup {
  id: string;
  name: string;
  department: string;
  year: string;
  strength: number;
}

export interface TimeSlot {
  day: string;
  time: string;
  period: "morning" | "afternoon";
}

export interface TimetableEntry {
  id: string;
  day: string;
  timeSlot: string;
  subject: Subject;
  staff: Staff;
  classroom: Classroom;
  studentGroup: StudentGroup;
  isAutoGenerated: boolean;
}

export interface Conflict {
  type: "staff_overlap" | "classroom_overlap" | "student_overlap" | "workload_violation";
  description: string;
  severity: "high" | "medium" | "low";
  entries: string[];
}

export class TimetableScheduler {
  private timeSlots: TimeSlot[] = [
    { day: "Monday", time: "08:00-09:00", period: "morning" },
    { day: "Monday", time: "09:00-10:00", period: "morning" },
    { day: "Monday", time: "10:00-11:00", period: "morning" },
    { day: "Monday", time: "11:00-12:00", period: "morning" },
    { day: "Monday", time: "12:00-13:00", period: "afternoon" },
    { day: "Monday", time: "13:00-14:00", period: "afternoon" },
    { day: "Monday", time: "14:00-15:00", period: "afternoon" },
    { day: "Monday", time: "15:00-16:00", period: "afternoon" },
    { day: "Monday", time: "16:00-17:00", period: "afternoon" },
    { day: "Tuesday", time: "08:00-09:00", period: "morning" },
    { day: "Tuesday", time: "09:00-10:00", period: "morning" },
    { day: "Tuesday", time: "10:00-11:00", period: "morning" },
    { day: "Tuesday", time: "11:00-12:00", period: "morning" },
    { day: "Tuesday", time: "12:00-13:00", period: "afternoon" },
    { day: "Tuesday", time: "13:00-14:00", period: "afternoon" },
    { day: "Tuesday", time: "14:00-15:00", period: "afternoon" },
    { day: "Tuesday", time: "15:00-16:00", period: "afternoon" },
    { day: "Tuesday", time: "16:00-17:00", period: "afternoon" },
    { day: "Wednesday", time: "08:00-09:00", period: "morning" },
    { day: "Wednesday", time: "09:00-10:00", period: "morning" },
    { day: "Wednesday", time: "10:00-11:00", period: "morning" },
    { day: "Wednesday", time: "11:00-12:00", period: "morning" },
    { day: "Wednesday", time: "12:00-13:00", period: "afternoon" },
    { day: "Wednesday", time: "13:00-14:00", period: "afternoon" },
    { day: "Wednesday", time: "14:00-15:00", period: "afternoon" },
    { day: "Wednesday", time: "15:00-16:00", period: "afternoon" },
    { day: "Wednesday", time: "16:00-17:00", period: "afternoon" },
    { day: "Thursday", time: "08:00-09:00", period: "morning" },
    { day: "Thursday", time: "09:00-10:00", period: "morning" },
    { day: "Thursday", time: "10:00-11:00", period: "morning" },
    { day: "Thursday", time: "11:00-12:00", period: "morning" },
    { day: "Thursday", time: "12:00-13:00", period: "afternoon" },
    { day: "Thursday", time: "13:00-14:00", period: "afternoon" },
    { day: "Thursday", time: "14:00-15:00", period: "afternoon" },
    { day: "Thursday", time: "15:00-16:00", period: "afternoon" },
    { day: "Thursday", time: "16:00-17:00", period: "afternoon" },
    { day: "Friday", time: "08:00-09:00", period: "morning" },
    { day: "Friday", time: "09:00-10:00", period: "morning" },
    { day: "Friday", time: "10:00-11:00", period: "morning" },
    { day: "Friday", time: "11:00-12:00", period: "morning" },
    { day: "Friday", time: "12:00-13:00", period: "afternoon" },
    { day: "Friday", time: "13:00-14:00", period: "afternoon" },
    { day: "Friday", time: "14:00-15:00", period: "afternoon" },
    { day: "Friday", time: "15:00-16:00", period: "afternoon" },
    { day: "Friday", time: "16:00-17:00", period: "afternoon" },
    { day: "Saturday", time: "08:00-09:00", period: "morning" },
    { day: "Saturday", time: "09:00-10:00", period: "morning" },
    { day: "Saturday", time: "10:00-11:00", period: "morning" },
    { day: "Saturday", time: "11:00-12:00", period: "morning" },
    { day: "Saturday", time: "12:00-13:00", period: "afternoon" },
  ];

  generateTimetable(
    subjects: Subject[],
    staff: Staff[],
    classrooms: Classroom[],
    studentGroups: StudentGroup[],
    department: string,
    year: string,
    semester: string
  ): { timetable: TimetableEntry[], conflicts: Conflict[] } {
    const timetable: TimetableEntry[] = [];
    const conflicts: Conflict[] = [];

    // Filter subjects for the specific department, year, and semester
    const relevantSubjects = subjects.filter(s => 
      s.department === department && s.year === year && s.semester === semester
    );

    // Filter staff for the department
    const relevantStaff = staff.filter(s => s.department === department);

    // Filter classrooms (prefer department-specific ones)
    const relevantClassrooms = classrooms.filter(c => 
      c.department === department || c.type === "lecture"
    );

    // Filter student groups for the department and year
    const relevantStudentGroups = studentGroups.filter(g => 
      g.department === department && g.year === year
    );

    // Sort subjects by priority (theory in morning, labs in afternoon)
    const sortedSubjects = relevantSubjects.sort((a, b) => {
      if (a.priority === "morning" && b.priority !== "morning") return -1;
      if (a.priority !== "morning" && b.priority === "morning") return 1;
      if (a.type === "theory" && b.type === "lab") return -1;
      if (a.type === "lab" && b.type === "theory") return 1;
      return 0;
    });

    // Track staff workload
    const staffWorkload: { [key: string]: number } = {};
    relevantStaff.forEach(s => {
      staffWorkload[s.id] = s.currentHours;
    });

    // Try to schedule each subject
    for (const subject of sortedSubjects) {
      const hoursNeeded = subject.credits;
      let scheduledHours = 0;

      // Find available staff
      const availableStaff = relevantStaff.filter(s => 
        (staffWorkload[s.id] + hoursNeeded) <= s.maxHours
      );

      if (availableStaff.length === 0) {
        conflicts.push({
          type: "workload_violation",
          description: `No available staff for ${subject.name} - all staff at capacity`,
          severity: "high",
          entries: []
        });
        continue;
      }

      // Select best staff (least loaded)
      const selectedStaff = availableStaff.reduce((prev, curr) => 
        staffWorkload[prev.id] < staffWorkload[curr.id] ? prev : curr
      );

      // Find appropriate classroom
      const suitableClassrooms = relevantClassrooms.filter(c => 
        (subject.type === "lab" && c.type === "lab") ||
        (subject.type === "theory" && (c.type === "lecture" || c.type === "seminar"))
      );

      if (suitableClassrooms.length === 0) {
        conflicts.push({
          type: "classroom_overlap",
          description: `No suitable classroom found for ${subject.name} (${subject.type})`,
          severity: "high",
          entries: []
        });
        continue;
      }

      // Select student group
      const studentGroup = relevantStudentGroups[0]; // Simplified - take first group

      if (!studentGroup) {
        conflicts.push({
          type: "student_overlap",
          description: `No student group found for ${subject.name}`,
          severity: "high",
          entries: []
        });
        continue;
      }

      // Find available time slots based on subject priority
      const preferredSlots = this.timeSlots.filter(slot => {
        if (subject.priority === "morning" && slot.period !== "morning") return false;
        if (subject.priority === "afternoon" && slot.period !== "afternoon") return false;
        return true;
      });

      // Try to schedule the required hours
      for (let i = 0; i < hoursNeeded && scheduledHours < hoursNeeded; i++) {
        const availableSlot = this.findAvailableSlot(
          preferredSlots,
          timetable,
          selectedStaff,
          suitableClassrooms[0],
          studentGroup
        );

        if (availableSlot) {
          const entry: TimetableEntry = {
            id: `auto-${Date.now()}-${Math.random()}`,
            day: availableSlot.day,
            timeSlot: availableSlot.time,
            subject,
            staff: selectedStaff,
            classroom: suitableClassrooms[0],
            studentGroup,
            isAutoGenerated: true
          };

          timetable.push(entry);
          staffWorkload[selectedStaff.id] += 1;
          scheduledHours += 1;
        } else {
          conflicts.push({
            type: "staff_overlap",
            description: `Could not find available slot for ${subject.name} - ${scheduledHours}/${hoursNeeded} hours scheduled`,
            severity: scheduledHours === 0 ? "high" : "medium",
            entries: []
          });
          break;
        }
      }
    }

    // Detect conflicts in the generated timetable
    const additionalConflicts = this.detectConflicts(timetable);
    conflicts.push(...additionalConflicts);

    return { timetable, conflicts };
  }

  private findAvailableSlot(
    timeSlots: TimeSlot[],
    existingTimetable: TimetableEntry[],
    staff: Staff,
    classroom: Classroom,
    studentGroup: StudentGroup
  ): TimeSlot | null {
    for (const slot of timeSlots) {
      const isSlotAvailable = !existingTimetable.some(entry => 
        entry.day === slot.day && 
        entry.timeSlot === slot.time && (
          entry.staff.id === staff.id ||
          entry.classroom.id === classroom.id ||
          entry.studentGroup.id === studentGroup.id
        )
      );

      if (isSlotAvailable) {
        return slot;
      }
    }

    return null;
  }

  private detectConflicts(timetable: TimetableEntry[]): Conflict[] {
    const conflicts: Conflict[] = [];

    // Group by day and time slot
    const slotMap: { [key: string]: TimetableEntry[] } = {};
    
    timetable.forEach(entry => {
      const key = `${entry.day}-${entry.timeSlot}`;
      if (!slotMap[key]) {
        slotMap[key] = [];
      }
      slotMap[key].push(entry);
    });

    // Check for conflicts in each slot
    Object.entries(slotMap).forEach(([slotKey, entries]) => {
      if (entries.length > 1) {
        // Check staff conflicts
        const staffIds = entries.map(e => e.staff.id);
        const uniqueStaffIds = [...new Set(staffIds)];
        if (staffIds.length !== uniqueStaffIds.length) {
          conflicts.push({
            type: "staff_overlap",
            description: `Staff conflict in ${slotKey} - same staff assigned to multiple classes`,
            severity: "high",
            entries: entries.map(e => e.id)
          });
        }

        // Check classroom conflicts
        const classroomIds = entries.map(e => e.classroom.id);
        const uniqueClassroomIds = [...new Set(classroomIds)];
        if (classroomIds.length !== uniqueClassroomIds.length) {
          conflicts.push({
            type: "classroom_overlap",
            description: `Classroom conflict in ${slotKey} - same room assigned to multiple classes`,
            severity: "high",
            entries: entries.map(e => e.id)
          });
        }

        // Check student group conflicts
        const studentGroupIds = entries.map(e => e.studentGroup.id);
        const uniqueStudentGroupIds = [...new Set(studentGroupIds)];
        if (studentGroupIds.length !== uniqueStudentGroupIds.length) {
          conflicts.push({
            type: "student_overlap",
            description: `Student group conflict in ${slotKey} - same group assigned to multiple classes`,
            severity: "high",
            entries: entries.map(e => e.id)
          });
        }
      }
    });

    return conflicts;
  }
}

export const timetableScheduler = new TimetableScheduler();
