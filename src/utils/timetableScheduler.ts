export interface Subject {
  id: string;
  name: string;
  code: string;
  type: "lab" | "theory";
  credits: number;
  department: string;
  year: string;
  semester: string;
  priority: "morning" | "afternoon" | "flexible";
  duration?: number; // in periods (1 for theory, 2+ for labs)
}

export interface Staff {
  id: string;
  name: string;
  role: "Prof" | "AsstProf";
  department: string;
  max_hours: number;
  current_hours: number;
  subjects?: string[]; // Subject codes this staff can teach
  is_active?: boolean;
}

export interface Classroom {
  id: string;
  name: string;
  type: "lecture" | "lab";
  capacity: number;
  department: string;
  is_active?: boolean;
}

export interface StudentGroup {
  id: string;
  name: string;
  department: string;
  year: string;
  strength: number;
}

export interface TimetableEntry {
  id: string;
  day: string;
  timeSlot: string;
  subject: string;
  subjectCode: string;
  staff: string;
  staffRole: string;
  classroom: string;
  studentGroup: string;
  type: string;
  hasConflict?: boolean;
  conflictType?: string;
  isAutoGenerated?: boolean;
  duration?: number; // number of consecutive periods
}

export interface Conflict {
  type: string;
  description: string;
  severity: "low" | "medium" | "high";
}

export interface ScheduleResult {
  timetable: TimetableEntry[];
  conflicts: Conflict[];
}

class TimetableScheduler {
  private days = ["Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"];
  
  // Updated timing structure with 6 periods of 55 minutes each
  private timeSlots = [
    "09:15-10:10", // Period 1
    "10:10-11:05", // Period 2
    "11:20-12:15", // Period 3 (after break)
    "13:00-13:55", // Period 4 (after lunch)
    "13:55-14:50", // Period 5
    "14:50-15:45"  // Period 6
  ];

  private preLunchSlots = ["09:15-10:10", "10:10-11:05", "11:20-12:15"];
  private postLunchSlots = ["13:00-13:55", "13:55-14:50", "14:50-15:45"];

  generateTimetable(
    subjects: Subject[],
    staff: Staff[],
    classrooms: Classroom[],
    studentGroups: StudentGroup[],
    department: string,
    year: string,
    semester: string
  ): ScheduleResult {
    const timetable: TimetableEntry[] = [];
    const conflicts: Conflict[] = [];

    try {
      // Enhanced pre-scheduling validation
      const { enhancedValidator } = await import("./enhancedTimetableValidator");
      const validationResult = enhancedValidator.validatePreSchedulingRequirements(
        subjects, staff, classrooms, studentGroups, department, year, semester
      );

      // Add validation conflicts
      conflicts.push(...validationResult.conflicts);

      // If there are high-severity conflicts, don't proceed with scheduling
      const highSeverityConflicts = conflicts.filter(c => c.severity === 'high');
      if (highSeverityConflicts.length > 0) {
        conflicts.push({
          type: "pre_scheduling_validation_failed",
          description: `Cannot proceed with scheduling due to ${highSeverityConflicts.length} critical issues. Please resolve them first.`,
          severity: "high"
        });
        return { timetable, conflicts };
      }

      const assignedSlots: Set<string> = new Set();
      const staffSchedule: Map<string, Set<string>> = new Map();
      const classroomSchedule: Map<string, Set<string>> = new Map();
      const studentGroupSchedule: Map<string, Set<string>> = new Map();

      // Filter subjects for the specific department, year, and semester
      const relevantSubjects = subjects.filter(
        subject => 
          subject.department === department && 
          subject.year === year && 
          subject.semester === semester
      );

      // Enhanced staff filtering with proper validation
      const departmentStaff = staff.filter(s => 
        s.department === department && 
        s.is_active !== false
      );
      
      // Filter active classrooms for the department
      const departmentClassrooms = classrooms.filter(c => 
        c.department === department && 
        c.is_active !== false
      );
      
      // Filter student groups for the department and year
      const relevantGroups = studentGroups.filter(
        group => group.department === department && group.year === year
      );

      if (relevantSubjects.length === 0) {
        conflicts.push({
          type: "no_subjects",
          description: `No subjects found for ${department} ${year} year ${semester} semester`,
          severity: "high"
        });
        return { timetable, conflicts };
      }

      // Initialize schedules
      departmentStaff.forEach(s => staffSchedule.set(s.id, new Set()));
      departmentClassrooms.forEach(c => classroomSchedule.set(c.id, new Set()));
      relevantGroups.forEach(g => studentGroupSchedule.set(g.id, new Set()));

      // Enhanced scheduling: Labs first (they need consecutive periods)
      const labSubjects = relevantSubjects.filter(s => s.type === "lab");
      const theorySubjects = relevantSubjects.filter(s => s.type === "theory");

      // Schedule labs with enhanced background checking
      for (const labSubject of labSubjects) {
        await this.scheduleLabSubjectEnhanced(
          labSubject,
          departmentStaff,
          departmentClassrooms,
          relevantGroups,
          timetable,
          conflicts,
          staffSchedule,
          classroomSchedule,
          studentGroupSchedule
        );
      }

      // Then schedule theory subjects
      for (const theorySubject of theorySubjects) {
        await this.scheduleTheorySubjectEnhanced(
          theorySubject,
          departmentStaff,
          departmentClassrooms,
          relevantGroups,
          timetable,
          conflicts,
          staffSchedule,
          classroomSchedule,
          studentGroupSchedule
        );
      }

      // Enhanced conflict validation with cross-department checks
      await this.validateScheduleEnhanced(timetable, conflicts, staff, classrooms, department);

    } catch (error) {
      conflicts.push({
        type: "system_error",
        description: `Enhanced scheduling failed: ${error instanceof Error ? error.message : 'Unknown error'}`,
        severity: "high"
      });
    }

    return { timetable, conflicts };
  }

  private async scheduleLabSubjectEnhanced(
    subject: Subject,
    staff: Staff[],
    classrooms: Classroom[],
    studentGroups: StudentGroup[],
    timetable: TimetableEntry[],
    conflicts: Conflict[],
    staffSchedule: Map<string, Set<string>>,
    classroomSchedule: Map<string, Set<string>>,
    studentGroupSchedule: Map<string, Set<string>>
  ): Promise<void> {
    const labDuration = subject.duration || 2;
    
    // Enhanced staff selection with subject expertise validation
    const qualifiedStaff = staff.filter(s => 
      s.current_hours + labDuration <= s.max_hours &&
      (!s.subjects || s.subjects.length === 0 || s.subjects.includes(subject.code)) &&
      s.is_active !== false
    );

    // Sort by experience (Prof > AsstProf) and current workload
    qualifiedStaff.sort((a, b) => {
      if (a.role === 'Prof' && b.role === 'AsstProf') return -1;
      if (a.role === 'AsstProf' && b.role === 'Prof') return 1;
      return (a.current_hours || 0) - (b.current_hours || 0);
    });

    const availableStaff = qualifiedStaff[0];
    if (!availableStaff) {
      conflicts.push({
        type: "no_qualified_lab_staff",
        description: `No qualified staff available for lab ${subject.name} with required expertise`,
        severity: "high"
      });
      return;
    }

    // Enhanced lab classroom selection
    const availableLabClassrooms = classrooms.filter(c => 
      c.type === "lab" && 
      c.is_active !== false
    );
    
    if (availableLabClassrooms.length === 0) {
      conflicts.push({
        type: "no_lab_classroom",
        description: `No active lab classroom available for ${subject.name}`,
        severity: "high"
      });
      return;
    }

    // Select best lab classroom based on capacity and facilities
    const bestLabClassroom = availableLabClassrooms.sort((a, b) => b.capacity - a.capacity)[0];

    // Find appropriate student group
    const studentGroup = studentGroups.find(g => g.strength <= bestLabClassroom.capacity);
    if (!studentGroup) {
      conflicts.push({
        type: "student_group_capacity_mismatch",
        description: `No student group fits in available lab classroom for ${subject.name}`,
        severity: "high"
      });
      return;
    }

    // Enhanced lab scheduling with consecutive period validation
    let scheduled = false;
    const preferredSlots = subject.priority === "morning" ? this.preLunchSlots : this.postLunchSlots;
    
    for (const day of this.days) {
      for (let i = 0; i <= preferredSlots.length - labDuration; i++) {
        const consecutiveSlots = preferredSlots.slice(i, i + labDuration);
        
        // Enhanced availability check
        const allSlotsAvailable = consecutiveSlots.every(timeSlot => {
          const staffKey = `${day}-${timeSlot}-${availableStaff.id}`;
          const classroomKey = `${day}-${timeSlot}-${bestLabClassroom.id}`;
          const groupKey = `${day}-${timeSlot}-${studentGroup.id}`;
          
          return !staffSchedule.get(availableStaff.id)?.has(staffKey) &&
                 !classroomSchedule.get(bestLabClassroom.id)?.has(classroomKey) &&
                 !studentGroupSchedule.get(studentGroup.id)?.has(groupKey);
        });

        if (allSlotsAvailable) {
          const startTime = consecutiveSlots[0];
          const endTime = consecutiveSlots[consecutiveSlots.length - 1].split('-')[1];
          const combinedTimeSlot = `${startTime.split('-')[0]}-${endTime}`;

          const entry: TimetableEntry = {
            id: `${subject.id}-${day}-${combinedTimeSlot}`,
            day,
            timeSlot: combinedTimeSlot,
            subject: subject.name,
            subjectCode: subject.code,
            staff: availableStaff.name,
            staffRole: availableStaff.role,
            classroom: bestLabClassroom.name,
            studentGroup: studentGroup.name,
            type: subject.type,
            hasConflict: false,
            isAutoGenerated: true,
            duration: labDuration
          };

          timetable.push(entry);

          // Mark all consecutive slots as occupied
          consecutiveSlots.forEach(timeSlot => {
            const staffKey = `${day}-${timeSlot}-${availableStaff.id}`;
            const classroomKey = `${day}-${timeSlot}-${bestLabClassroom.id}`;
            const groupKey = `${day}-${timeSlot}-${studentGroup.id}`;
            
            staffSchedule.get(availableStaff.id)?.add(staffKey);
            classroomSchedule.get(bestLabClassroom.id)?.add(classroomKey);
            studentGroupSchedule.get(studentGroup.id)?.add(groupKey);
          });

          // Update staff hours
          availableStaff.current_hours = (availableStaff.current_hours || 0) + labDuration;
          scheduled = true;
          break;
        }
      }
      if (scheduled) break;
    }

    if (!scheduled) {
      conflicts.push({
        type: "lab_scheduling_failed",
        description: `Could not schedule lab ${subject.name} - no ${labDuration} consecutive periods available after enhanced validation`,
        severity: "high"
      });
    }
  }

  private async scheduleTheorySubjectEnhanced(
    subject: Subject,
    staff: Staff[],
    classrooms: Classroom[],
    studentGroups: StudentGroup[],
    timetable: TimetableEntry[],
    conflicts: Conflict[],
    staffSchedule: Map<string, Set<string>>,
    classroomSchedule: Map<string, Set<string>>,
    studentGroupSchedule: Map<string, Set<string>>
  ): Promise<void> {
    // Enhanced theory staff selection
    const qualifiedStaff = staff.filter(s => 
      s.current_hours < s.max_hours &&
      (!s.subjects || s.subjects.length === 0 || s.subjects.includes(subject.code)) &&
      s.is_active !== false
    );

    qualifiedStaff.sort((a, b) => {
      if (a.role === 'Prof' && b.role === 'AsstProf') return -1;
      if (a.role === 'AsstProf' && b.role === 'Prof') return 1;
      return (a.current_hours || 0) - (b.current_hours || 0);
    });

    const availableStaff = qualifiedStaff[0];
    if (!availableStaff) {
      conflicts.push({
        type: "no_qualified_theory_staff",
        description: `No qualified staff available for theory subject ${subject.name}`,
        severity: "high"
      });
      return;
    }

    // Enhanced lecture classroom selection
    const availableLectureClassrooms = classrooms.filter(c => 
      c.type === "lecture" && 
      c.is_active !== false
    );

    if (availableLectureClassrooms.length === 0) {
      conflicts.push({
        type: "no_lecture_classroom",
        description: `No active lecture classroom available for ${subject.name}`,
        severity: "high"
      });
      return;
    }

    const bestLectureClassroom = availableLectureClassrooms.sort((a, b) => b.capacity - a.capacity)[0];

    const studentGroup = studentGroups.find(g => g.strength <= bestLectureClassroom.capacity);
    if (!studentGroup) {
      conflicts.push({
        type: "student_group_capacity_mismatch",
        description: `No student group fits in available lecture classroom for ${subject.name}`,
        severity: "high"
      });
      return;
    }

    // Enhanced theory scheduling
    let scheduled = false;
    const preferredSlots = this.getPreferredTimeSlots(subject.priority);
    
    for (const day of this.days) {
      for (const timeSlot of preferredSlots) {
        const staffKey = `${day}-${timeSlot}-${availableStaff.id}`;
        const classroomKey = `${day}-${timeSlot}-${bestLectureClassroom.id}`;
        const groupKey = `${day}-${timeSlot}-${studentGroup.id}`;
        
        if (!staffSchedule.get(availableStaff.id)?.has(staffKey) &&
            !classroomSchedule.get(bestLectureClassroom.id)?.has(classroomKey) &&
            !studentGroupSchedule.get(studentGroup.id)?.has(groupKey)) {
          
          const entry: TimetableEntry = {
            id: `${subject.id}-${day}-${timeSlot}`,
            day,
            timeSlot,
            subject: subject.name,
            subjectCode: subject.code,
            staff: availableStaff.name,
            staffRole: availableStaff.role,
            classroom: bestLectureClassroom.name,
            studentGroup: studentGroup.name,
            type: subject.type,
            hasConflict: false,
            isAutoGenerated: true,
            duration: 1
          };

          timetable.push(entry);
          
          staffSchedule.get(availableStaff.id)?.add(staffKey);
          classroomSchedule.get(bestLectureClassroom.id)?.add(classroomKey);
          studentGroupSchedule.get(studentGroup.id)?.add(groupKey);
          
          availableStaff.current_hours = (availableStaff.current_hours || 0) + 1;
          scheduled = true;
          break;
        }
      }
      if (scheduled) break;
    }

    if (!scheduled) {
      conflicts.push({
        type: "theory_scheduling_failed",
        description: `Could not schedule theory subject ${subject.name} after enhanced validation`,
        severity: "medium"
      });
    }
  }

  private getPreferredTimeSlots(priority: "morning" | "afternoon" | "flexible"): string[] {
    switch (priority) {
      case "morning":
        return [...this.preLunchSlots, ...this.postLunchSlots];
      case "afternoon":
        return [...this.postLunchSlots, ...this.preLunchSlots];
      default:
        return [...this.preLunchSlots, ...this.postLunchSlots];
    }
  }

  private async validateScheduleEnhanced(
    timetable: TimetableEntry[], 
    conflicts: Conflict[], 
    allStaff: Staff[], 
    allClassrooms: Classroom[], 
    department: string
  ): Promise<void> {
    // Enhanced validation with cross-department conflict checking
    try {
      const { enhancedValidator } = await import("./enhancedTimetableValidator");
      const crossDepartmentValidation = enhancedValidator.validateCrossDepartmentConflicts(
        allStaff, allClassrooms, department, timetable
      );
      conflicts.push(...crossDepartmentValidation.conflicts);
    } catch (error) {
      console.warn("Cross-department validation failed:", error);
    }

    // Existing validation logic
    const slotMap = new Map<string, TimetableEntry[]>();
    
    timetable.forEach(entry => {
      if (entry.duration && entry.duration > 1) {
        // Handle multi-period entries
        const [startTime] = entry.timeSlot.split('-');
        const startIndex = this.timeSlots.findIndex(slot => slot.startsWith(startTime));
        
        for (let i = 0; i < entry.duration; i++) {
          if (startIndex + i < this.timeSlots.length) {
            const periodSlot = this.timeSlots[startIndex + i];
            const key = `${entry.day}-${periodSlot}`;
            if (!slotMap.has(key)) {
              slotMap.set(key, []);
            }
            slotMap.get(key)!.push(entry);
          }
        }
      } else {
        const key = `${entry.day}-${entry.timeSlot}`;
        if (!slotMap.has(key)) {
          slotMap.set(key, []);
        }
        slotMap.get(key)!.push(entry);
      }
    });

    // Check for conflicts
    slotMap.forEach((entries, slot) => {
      if (entries.length > 1) {
        const staffConflicts = this.findDuplicates(entries, 'staff');
        const classroomConflicts = this.findDuplicates(entries, 'classroom');
        const groupConflicts = this.findDuplicates(entries, 'studentGroup');

        staffConflicts.forEach(staff => {
          conflicts.push({
            type: "staff_conflict",
            description: `Staff ${staff} has multiple classes at ${slot}`,
            severity: "high"
          });
        });

        classroomConflicts.forEach(classroom => {
          conflicts.push({
            type: "classroom_conflict",
            description: `Classroom ${classroom} has multiple classes at ${slot}`,
            severity: "high"
          });
        });

        groupConflicts.forEach(group => {
          conflicts.push({
            type: "student_group_conflict",
            description: `Student group ${group} has multiple classes at ${slot}`,
            severity: "high"
          });
        });
      }
    });

    // Enhanced lab validation
    this.validateLabSchedulingEnhanced(timetable, conflicts);
  }

  private validateLabSchedulingEnhanced(timetable: TimetableEntry[], conflicts: Conflict[]): void {
    const labEntries = timetable.filter(entry => entry.type === "lab");
    
    labEntries.forEach(lab => {
      // Validate lab duration
      if (!lab.duration || lab.duration < 2) {
        conflicts.push({
          type: "insufficient_lab_duration",
          description: `Lab ${lab.subject} has insufficient duration (${lab.duration || 1} periods). Minimum 2 periods required.`,
          severity: "medium"
        });
      }

      // Validate lab timing preferences
      const isAfternoon = this.postLunchSlots.some(slot => lab.timeSlot.includes(slot.split('-')[0]));
      if (!isAfternoon) {
        conflicts.push({
          type: "lab_timing_suboptimal",
          description: `Lab ${lab.subject} scheduled in morning. Afternoon scheduling recommended.`,
          severity: "low"
        });
      }

      // Validate consecutive periods for labs
      if (lab.duration && lab.duration > 1) {
        const [startTime] = lab.timeSlot.split('-');
        const startIndex = this.timeSlots.findIndex(slot => slot.startsWith(startTime));
        
        if (startIndex === -1 || startIndex + lab.duration > this.timeSlots.length) {
          conflicts.push({
            type: "lab_period_continuity",
            description: `Lab ${lab.subject} periods may not be continuous or exceed available time slots`,
            severity: "medium"
          });
        }
      }
    });
  }

  private findDuplicates(entries: TimetableEntry[], field: keyof TimetableEntry): string[] {
    const seen = new Set<string>();
    const duplicates = new Set<string>();
    
    entries.forEach(entry => {
      const value = entry[field] as string;
      if (seen.has(value)) {
        duplicates.add(value);
      } else {
        seen.add(value);
      }
    });
    
    return Array.from(duplicates);
  }
}

export const timetableScheduler = new TimetableScheduler();
