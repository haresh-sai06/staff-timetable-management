
export interface Subject {
  id: string;
  name: string;
  code: string;
  type: "lab" | "theory";
  credits: number;
  department: string;
  year: string;
  semester: string;
  priority: "morning" | "afternoon" | "flexible";
  duration?: number; // in periods (1 for theory, 2+ for labs)
}

export interface Staff {
  id: string;
  name: string;
  role: "Prof" | "AsstProf";
  department: string;
  maxHours: number;
  currentHours: number;
  subjects?: string[]; // Subject codes this staff can teach
}

export interface Classroom {
  id: string;
  name: string;
  type: "lecture" | "lab";
  capacity: number;
  department: string;
}

export interface StudentGroup {
  id: string;
  name: string;
  department: string;
  year: string;
  strength: number;
}

export interface TimetableEntry {
  id: string;
  day: string;
  timeSlot: string;
  subject: string;
  subjectCode: string;
  staff: string;
  staffRole: string;
  classroom: string;
  studentGroup: string;
  type: string;
  hasConflict?: boolean;
  conflictType?: string;
  isAutoGenerated?: boolean;
  duration?: number; // number of consecutive periods
}

export interface Conflict {
  type: string;
  description: string;
  severity: "low" | "medium" | "high";
}

export interface ScheduleResult {
  timetable: TimetableEntry[];
  conflicts: Conflict[];
}

class TimetableScheduler {
  private days = ["Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"];
  
  // Updated timing structure with 6 periods of 55 minutes each
  private timeSlots = [
    "09:15-10:10", // Period 1
    "10:10-11:05", // Period 2
    "11:20-12:15", // Period 3 (after break)
    "13:00-13:55", // Period 4 (after lunch)
    "13:55-14:50", // Period 5
    "14:50-15:45"  // Period 6
  ];

  private preLunchSlots = ["09:15-10:10", "10:10-11:05", "11:20-12:15"];
  private postLunchSlots = ["13:00-13:55", "13:55-14:50", "14:50-15:45"];

  generateTimetable(
    subjects: Subject[],
    staff: Staff[],
    classrooms: Classroom[],
    studentGroups: StudentGroup[],
    department: string,
    year: string,
    semester: string
  ): ScheduleResult {
    const timetable: TimetableEntry[] = [];
    const conflicts: Conflict[] = [];
    const assignedSlots: Set<string> = new Set();
    const staffSchedule: Map<string, Set<string>> = new Map();
    const classroomSchedule: Map<string, Set<string>> = new Map();
    const studentGroupSchedule: Map<string, Set<string>> = new Map();

    try {
      // Filter subjects for the specific department, year, and semester
      const relevantSubjects = subjects.filter(
        subject => 
          subject.department === department && 
          subject.year === year && 
          subject.semester === semester
      );

      // Enhanced staff filtering with subject compatibility
      const departmentStaff = staff.filter(s => s.department === department);
      
      // Filter classrooms for the department
      const departmentClassrooms = classrooms.filter(c => c.department === department);
      
      // Filter student groups for the department and year
      const relevantGroups = studentGroups.filter(
        group => group.department === department && group.year === year
      );

      if (relevantSubjects.length === 0) {
        conflicts.push({
          type: "no_subjects",
          description: `No subjects found for ${department} ${year} year ${semester} semester`,
          severity: "high"
        });
        return { timetable, conflicts };
      }

      // Initialize schedules
      departmentStaff.forEach(s => staffSchedule.set(s.id, new Set()));
      departmentClassrooms.forEach(c => classroomSchedule.set(c.id, new Set()));
      relevantGroups.forEach(g => studentGroupSchedule.set(g.id, new Set()));

      // Separate labs and theory subjects for better scheduling
      const labSubjects = relevantSubjects.filter(s => s.type === "lab");
      const theorySubjects = relevantSubjects.filter(s => s.type === "theory");

      // Schedule labs first (they need consecutive periods and specific requirements)
      for (const labSubject of labSubjects) {
        this.scheduleLabSubject(
          labSubject,
          departmentStaff,
          departmentClassrooms,
          relevantGroups,
          timetable,
          conflicts,
          staffSchedule,
          classroomSchedule,
          studentGroupSchedule
        );
      }

      // Then schedule theory subjects
      for (const theorySubject of theorySubjects) {
        this.scheduleTheorySubject(
          theorySubject,
          departmentStaff,
          departmentClassrooms,
          relevantGroups,
          timetable,
          conflicts,
          staffSchedule,
          classroomSchedule,
          studentGroupSchedule
        );
      }

      // Enhanced conflict validation
      this.validateScheduleEnhanced(timetable, conflicts);

    } catch (error) {
      conflicts.push({
        type: "system_error",
        description: `Scheduling failed: ${error instanceof Error ? error.message : 'Unknown error'}`,
        severity: "high"
      });
    }

    return { timetable, conflicts };
  }

  private scheduleLabSubject(
    subject: Subject,
    staff: Staff[],
    classrooms: Classroom[],
    studentGroups: StudentGroup[],
    timetable: TimetableEntry[],
    conflicts: Conflict[],
    staffSchedule: Map<string, Set<string>>,
    classroomSchedule: Map<string, Set<string>>,
    studentGroupSchedule: Map<string, Set<string>>
  ): void {
    const labDuration = subject.duration || 2; // Default 2 periods for labs
    
    // Find available lab staff (with subject expertise if specified)
    const availableStaff = staff.find(s => 
      s.currentHours + labDuration <= s.maxHours &&
      (!s.subjects || s.subjects.includes(subject.code))
    );

    if (!availableStaff) {
      conflicts.push({
        type: "staff_unavailable",
        description: `No available qualified staff for lab ${subject.name}`,
        severity: "high"
      });
      return;
    }

    // Find available lab classroom
    const availableLabClassroom = classrooms.find(c => c.type === "lab");
    if (!availableLabClassroom) {
      conflicts.push({
        type: "classroom_unavailable",
        description: `No lab classroom available for ${subject.name}`,
        severity: "high"
      });
      return;
    }

    // Find student group
    const studentGroup = studentGroups[0];
    if (!studentGroup) {
      conflicts.push({
        type: "no_student_group",
        description: `No student group found for ${subject.name}`,
        severity: "high"
      });
      return;
    }

    // Try to schedule lab with consecutive periods
    let scheduled = false;
    const preferredSlots = subject.priority === "morning" ? this.preLunchSlots : this.postLunchSlots;
    
    for (const day of this.days) {
      for (let i = 0; i <= preferredSlots.length - labDuration; i++) {
        const consecutiveSlots = preferredSlots.slice(i, i + labDuration);
        
        // Check if all consecutive slots are available
        const allSlotsAvailable = consecutiveSlots.every(timeSlot => {
          const staffKey = `${day}-${timeSlot}-${availableStaff.id}`;
          const classroomKey = `${day}-${timeSlot}-${availableLabClassroom.id}`;
          const groupKey = `${day}-${timeSlot}-${studentGroup.id}`;
          
          return !staffSchedule.get(availableStaff.id)?.has(staffKey) &&
                 !classroomSchedule.get(availableLabClassroom.id)?.has(classroomKey) &&
                 !studentGroupSchedule.get(studentGroup.id)?.has(groupKey);
        });

        if (allSlotsAvailable) {
          // Schedule the lab for consecutive periods
          const startTime = consecutiveSlots[0];
          const endTime = consecutiveSlots[consecutiveSlots.length - 1].split('-')[1];
          const combinedTimeSlot = `${startTime.split('-')[0]}-${endTime}`;

          const entry: TimetableEntry = {
            id: `${subject.id}-${day}-${combinedTimeSlot}`,
            day,
            timeSlot: combinedTimeSlot,
            subject: subject.name,
            subjectCode: subject.code,
            staff: availableStaff.name,
            staffRole: availableStaff.role,
            classroom: availableLabClassroom.name,
            studentGroup: studentGroup.name,
            type: subject.type,
            hasConflict: false,
            isAutoGenerated: true,
            duration: labDuration
          };

          timetable.push(entry);

          // Mark all consecutive slots as occupied
          consecutiveSlots.forEach(timeSlot => {
            const staffKey = `${day}-${timeSlot}-${availableStaff.id}`;
            const classroomKey = `${day}-${timeSlot}-${availableLabClassroom.id}`;
            const groupKey = `${day}-${timeSlot}-${studentGroup.id}`;
            
            staffSchedule.get(availableStaff.id)?.add(staffKey);
            classroomSchedule.get(availableLabClassroom.id)?.add(classroomKey);
            studentGroupSchedule.get(studentGroup.id)?.add(groupKey);
          });

          // Update staff hours
          availableStaff.currentHours += labDuration;
          scheduled = true;
          break;
        }
      }
      if (scheduled) break;
    }

    if (!scheduled) {
      conflicts.push({
        type: "lab_scheduling_conflict",
        description: `Could not schedule lab ${subject.name} - no ${labDuration} consecutive periods available`,
        severity: "medium"
      });
    }
  }

  private scheduleTheorySubject(
    subject: Subject,
    staff: Staff[],
    classrooms: Classroom[],
    studentGroups: StudentGroup[],
    timetable: TimetableEntry[],
    conflicts: Conflict[],
    staffSchedule: Map<string, Set<string>>,
    classroomSchedule: Map<string, Set<string>>,
    studentGroupSchedule: Map<string, Set<string>>
  ): void {
    // Find available theory staff
    const availableStaff = staff.find(s => 
      s.currentHours < s.maxHours &&
      (!s.subjects || s.subjects.includes(subject.code))
    );

    if (!availableStaff) {
      conflicts.push({
        type: "staff_unavailable",
        description: `No available qualified staff for ${subject.name}`,
        severity: "high"
      });
      return;
    }

    // Find available lecture classroom
    const availableLectureClassroom = classrooms.find(c => c.type === "lecture");
    if (!availableLectureClassroom) {
      conflicts.push({
        type: "classroom_unavailable",
        description: `No lecture classroom available for ${subject.name}`,
        severity: "high"
      });
      return;
    }

    // Find student group
    const studentGroup = studentGroups[0];
    if (!studentGroup) {
      conflicts.push({
        type: "no_student_group",
        description: `No student group found for ${subject.name}`,
        severity: "high"
      });
      return;
    }

    // Try to schedule theory subject
    let scheduled = false;
    const preferredSlots = this.getPreferredTimeSlots(subject.priority);
    
    for (const day of this.days) {
      for (const timeSlot of preferredSlots) {
        const staffKey = `${day}-${timeSlot}-${availableStaff.id}`;
        const classroomKey = `${day}-${timeSlot}-${availableLectureClassroom.id}`;
        const groupKey = `${day}-${timeSlot}-${studentGroup.id}`;
        
        if (!staffSchedule.get(availableStaff.id)?.has(staffKey) &&
            !classroomSchedule.get(availableLectureClassroom.id)?.has(classroomKey) &&
            !studentGroupSchedule.get(studentGroup.id)?.has(groupKey)) {
          
          const entry: TimetableEntry = {
            id: `${subject.id}-${day}-${timeSlot}`,
            day,
            timeSlot,
            subject: subject.name,
            subjectCode: subject.code,
            staff: availableStaff.name,
            staffRole: availableStaff.role,
            classroom: availableLectureClassroom.name,
            studentGroup: studentGroup.name,
            type: subject.type,
            hasConflict: false,
            isAutoGenerated: true,
            duration: 1
          };

          timetable.push(entry);
          
          staffSchedule.get(availableStaff.id)?.add(staffKey);
          classroomSchedule.get(availableLectureClassroom.id)?.add(classroomKey);
          studentGroupSchedule.get(studentGroup.id)?.add(groupKey);
          
          // Update staff hours
          availableStaff.currentHours += 1;
          scheduled = true;
          break;
        }
      }
      if (scheduled) break;
    }

    if (!scheduled) {
      conflicts.push({
        type: "theory_scheduling_conflict",
        description: `Could not schedule ${subject.name} - no available time slots`,
        severity: "medium"
      });
    }
  }

  private getPreferredTimeSlots(priority: "morning" | "afternoon" | "flexible"): string[] {
    switch (priority) {
      case "morning":
        return [...this.preLunchSlots, ...this.postLunchSlots];
      case "afternoon":
        return [...this.postLunchSlots, ...this.preLunchSlots];
      default:
        return [...this.preLunchSlots, ...this.postLunchSlots];
    }
  }

  private validateScheduleEnhanced(timetable: TimetableEntry[], conflicts: Conflict[]): void {
    // Check for conflicts in the generated timetable
    const slotMap = new Map<string, TimetableEntry[]>();
    
    timetable.forEach(entry => {
      // For multi-period entries, check each individual period
      if (entry.duration && entry.duration > 1) {
        const [startTime, endTime] = entry.timeSlot.split('-');
        const startHour = parseInt(startTime.split(':')[0]);
        const startMinute = parseInt(startTime.split(':')[1]);
        
        for (let i = 0; i < entry.duration; i++) {
          const periodStart = new Date();
          periodStart.setHours(startHour, startMinute + (i * 55), 0, 0);
          const periodEnd = new Date();
          periodEnd.setHours(startHour, startMinute + ((i + 1) * 55), 0, 0);
          
          const periodSlot = `${entry.day}-${periodStart.toTimeString().slice(0, 5)}-${periodEnd.toTimeString().slice(0, 5)}`;
          
          if (!slotMap.has(periodSlot)) {
            slotMap.set(periodSlot, []);
          }
          slotMap.get(periodSlot)!.push(entry);
        }
      } else {
        const key = `${entry.day}-${entry.timeSlot}`;
        if (!slotMap.has(key)) {
          slotMap.set(key, []);
        }
        slotMap.get(key)!.push(entry);
      }
    });

    // Check for multiple entries in same slot for same resource
    slotMap.forEach((entries, slot) => {
      if (entries.length > 1) {
        const staffConflicts = this.findDuplicates(entries, 'staff');
        const classroomConflicts = this.findDuplicates(entries, 'classroom');
        const groupConflicts = this.findDuplicates(entries, 'studentGroup');

        staffConflicts.forEach(staff => {
          conflicts.push({
            type: "staff_conflict",
            description: `${staff} has multiple classes scheduled at ${slot}`,
            severity: "high"
          });
        });

        classroomConflicts.forEach(classroom => {
          conflicts.push({
            type: "classroom_conflict",
            description: `${classroom} has multiple classes scheduled at ${slot}`,
            severity: "high"
          });
        });

        groupConflicts.forEach(group => {
          conflicts.push({
            type: "student_group_conflict",
            description: `${group} has multiple classes scheduled at ${slot}`,
            severity: "high"
          });
        });
      }
    });

    // Additional validation for lab scheduling
    this.validateLabScheduling(timetable, conflicts);
  }

  private validateLabScheduling(timetable: TimetableEntry[], conflicts: Conflict[]): void {
    const labEntries = timetable.filter(entry => entry.type === "lab");
    
    labEntries.forEach(lab => {
      // Check if lab has sufficient duration
      if (!lab.duration || lab.duration < 2) {
        conflicts.push({
          type: "lab_duration_warning",
          description: `Lab ${lab.subject} may need longer duration than ${lab.duration || 1} period(s)`,
          severity: "low"
        });
      }

      // Check if lab is scheduled in appropriate time slots
      const isInAfternoon = this.postLunchSlots.some(slot => lab.timeSlot.includes(slot));
      if (!isInAfternoon && lab.type === "lab") {
        conflicts.push({
          type: "lab_timing_suggestion",
          description: `Lab ${lab.subject} is scheduled in morning - consider afternoon scheduling`,
          severity: "low"
        });
      }
    });
  }

  private findDuplicates(entries: TimetableEntry[], field: keyof TimetableEntry): string[] {
    const seen = new Set<string>();
    const duplicates = new Set<string>();
    
    entries.forEach(entry => {
      const value = entry[field] as string;
      if (seen.has(value)) {
        duplicates.add(value);
      } else {
        seen.add(value);
      }
    });
    
    return Array.from(duplicates);
  }
}

export const timetableScheduler = new TimetableScheduler();
